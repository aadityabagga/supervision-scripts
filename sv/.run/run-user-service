#!/bin/sh

# A minimalist user-controlled service launch script.

# shunt all error logging to stdout
exec 2>&1

# to ensure that all of the standard commands
# of daemontools are supported, intercept the
# path and give our local copy priority.  All
# of the symlinks in .bin point to their
# equivalent in whatever framework is installed,
# ensuring correct behavior.

PATH=../.bin:$PATH

# determine the supervision scanning process along with the user name
SOMESUPER=$( basename $( pwd ) )
SVSCAN=$(echo $SOMESUPER | sed 's/-/ /' | awk '{ print $1 }' )
THISUSER=$(echo $SOMESUPER | sed 's/-/ /' | awk '{ print $2 }' )

# framework-specific dependency: make runit's supervision directory
# accessable to the user that will control the service
chmod 755 ./supervise
chown $THISUSER ./supervise/*

# apply framework-specific options.
# daemontools: uses svscan, does not take arguments
# runit: uses runsvdir, takes a single process group argument
# s6: uses s6-svscan, takes up to two arguments.  The variable
# SVOPTS is intentionally left undefined as we want the script
# to fail for a framework name that is not supported.

# daemontools
[ $SVSCAN = 'svscan' ] && SVOPTS=""

# runit
# NOTE: SVOPTS is conditional on the supervise directory being adjusted
# so that a failure in adjustment prevents launch (which would fail anyways)
[ $SVSCAN = 'runsvdir' ] && chmod 755 ./supervise && chown $THISUSER ./supervise/* && SVOPTS="-P"

# s6
# NOTE: the maximum limit has been raised to 1000 processes to
# match the other frameworks
[ $SVSCAN = 's6-svscan' ] && SVOPTS="-c 1000"

# launch
exec setuidgid $THISUSER $SVSCAN $SVOPTS /home/$THISUSER/service
